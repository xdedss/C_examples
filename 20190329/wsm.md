# A 空游的草坪

wwWWwwwWwwwwwWWWWwwW

# B 多项式求值II

和之前的题基本上一样  
只要在读取的时候求导，令 ki = ki * pi， pi = pi - 1即可  

# C 真心话大冒险

## 思路

对于前n-1个人，求出每一个人的真心话传到第n个人所需的次数，取最大值。

## 实现

为了方便计算，定义函数path，计算从一个人到另一个人所需的次数。

```c
//参数p为储存每个人要传给的人的数组
int path(int from, int to, int p[]){
  int n = 0;//次数
  while(1){
    if(from == to){
      //如果已经传到了就可以返回记录下的次数
      return n;
    }
    //利用from记录传到的人，从p中取出下一个人，赋给from
    from = p[from];
    //次数增加
    n++;
  }
}
```

main函数中，读取人数n和每个人指向的下一个人，为了与数组下标统一，把读入的指向序号减一。  
对每一个人，调用path函数求出次数，并与已有最大值比较，求出最大值。  

```c
main(){
  int n, i;
  scanf("%d", &n);
  int p[n];//每一个人指向的下一个人
  for(i = 0; i < n; i++){
    scanf("%d", &p[i]);
    //与数组下标统一
    p[i]--;
  }
  int max = 0;
  for(i = 0; i < n; i++){
    //调用path， 传入开始者i和目标n-1，以及数组p
    int t = path(i, n - 1, p);
    if(t > max){
      max = t;
    }
  }
  printf("%d", max);
}
```

# D 数分

## 最简单的方法

因为 0≤x≤9，所以......

```c
char *res[] = {"2", "1.7", "1.72", "1.718", "1.7183", "1.71828", "1.718282", "1.7182818", "1.71828183", "1.718281828"};
printf(res[x]);
```

# E 学长的简陋计算器

读取的时候

```c
double a, b;
char op;
scanf("%lf%c%lf", &a, &op, &b);
```

之后可以

```c
switch(op){
    case '+':
        ...
    case '-':
        ...
    ...
    ...
    ...
    ...
}
```

# F 矩阵乘法I

二维数组定义

```c
int a[n][n];//n行n列的数组
```

二维数组取值/赋值

```c
a[i][j] = 1;//a的第i行第j个元素
printf("%d", a[i][j]);
```
