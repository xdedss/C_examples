# A 空游的草坪

wwWWwwwWwwwwwWWWWwwW

# B 多项式求值II

和之前的题基本上一样  
只要在读取的时候求导，令 ki = ki * pi， pi = pi - 1即可  

# C 真心话大冒险

## 思路

这题其实是给出了每一个人传给下一个人的“指向”，每一轮中，每个人都把自己**在这一轮开始之前知道的信息**告诉他指向的那个人。  
注意是开始之前知道的信息，不包括这一轮中途从别人那里听到的信息。  
比如说输入：
```
3
2 3 1
```
那么第一轮中，1告诉2，2告诉3，3告诉1，这时结果是1知道1、3，2知道2、1，3知道3、2。这时3不知道1的信息。  
  
  
对于前n-1个人，求出每一个人的真心话传到第n个人所需的次数，取最大值。  

## 实现

为了方便计算，定义函数path，计算从一个人到另一个人所需的次数。

```c
//求从第a个人到第b个人的路径长度
//参数p为储存每个人要传给的人的数组
int path(int a, int b, int p[]){
  int n = 0;//次数
  while(1){
    if(a == b){
      //如果已经传到了就可以返回记录下的次数
      return n;
    }
    //利用a记录传到的人，从p中取出a对应的下一个人，赋给a
    a = p[a];
    //次数增加
    n++;
  }
}
```

main函数中，读取人数n和每个人指向的下一个人，为了与数组下标统一，把读入的指向序号减一。  
对每一个人，调用path函数求出次数，并与已有最大值比较，求出最大值。  

```c
main(){
  int n, i;
  scanf("%d", &n);
  int p[n];//用来存储每一个人指向的下一个人
  for(i = 0; i < n; i++){
    scanf("%d", &p[i]);
    //与数组下标统一
    p[i]--;
  }
  int max = 0;
  for(i = 0; i < n; i++){
    //调用path， 传入开始者i和目标n-1，以及数组p
    int t = path(i, n - 1, p);
    if(t > max){
      max = t;
    }
  }
  printf("%d", max);
}
```

# D 数分

## 最简单的方法

因为 0≤x≤9，所以可以全都列出来......

```c
char *res[] = {"2", "1.7", "1.72", "1.718", "1.7183", "1.71828", "1.718282", "1.7182818", "1.71828183", "1.718281828"};
printf(res[x]);
```

# E 学长的简陋计算器

读取的时候

```c
double a, b;
char op;
scanf("%lf%c%lf", &a, &op, &b);
```

之后可以

```c
switch(op){
    case '+':
        ...
    case '-':
        ...
    ...
    ...
    ...
    ...
}
```

# F 矩阵乘法I

二维数组定义

```c
int a[n][n];//n行n列的数组
```

二维数组取值/赋值

```c
a[i][j] = 1;//a的第i行第j个元素
printf("%d", a[i][j]);
```
